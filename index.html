<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>oVice Poll Sync Fix</title>
    <style>
        body { font-family: sans-serif; padding: 12px; background: #fff; margin: 0; }
        .poll-card { border: 1px solid #eee; border-radius: 12px; padding: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.05); }
        h3 { font-size: 18px; margin: 0 0 15px 0; border-left: 4px solid #0096ff; padding-left: 10px; }
        .option-btn {
            display: block; width: 100%; padding: 12px; margin: 8px 0;
            background: #f8f9fa; border: 1px solid #e9ecef; border-radius: 8px;
            cursor: pointer; text-align: left; position: relative; overflow: hidden;
            user-select: none;
        }
        .option-btn:active { opacity: 0.6; }
        .bar { position: absolute; left: 0; top: 0; bottom: 0; background: rgba(0, 150, 255, 0.15); transition: width 0.4s; }
        .label-text { position: relative; z-index: 1; }
        .count { float: right; position: relative; z-index: 1; font-weight: bold; color: #0076cc; }
        .status { font-size: 9px; color: #bbb; text-align: center; margin-top: 8px; }
    </style>
</head>
<body>

<div class="poll-card">
    <h3 id="poll-title">CSV Loading...</h3>
    <div id="options"></div>
    <div id="sync-info" class="status">Sync: Waiting for oVice...</div>
</div>

<script>
/** * oVice 通信プロトコル 最終調整版
 */
const OviceBridge = (() => {
    let _onUpdate = null;
    let _callbackId = 0;
    const _pending = {};

    window.addEventListener('message', e => {
        if (!e.data) return;
        // 1. 同期更新を受け取る
        if (e.data.type === 'storage' || e.data.event === 'storageChanged') {
            if (_onUpdate) _onUpdate(e.data.key, e.data.value);
        }
        // 2. getStorageなどの返信を受け取る
        if (e.data.callbackId && _pending[e.data.callbackId]) {
            _pending[e.data.callbackId](e.data.value);
            delete _pending[e.data.callbackId];
        }
    });

    const send = (type, payload = {}) => {
        const callbackId = ++_callbackId;
        return new Promise(resolve => {
            _pending[callbackId] = resolve;
            window.parent.postMessage({ type, callbackId, ...payload }, '*');
        });
    };

    return {
        init: () => send('init'),
        get: (key) => send('get_storage', { key }),
        set: (key, value) => window.parent.postMessage({ type: 'set_storage', key, value }, '*'),
        onChange: (cb) => { _onUpdate = cb; }
    };
})();

let pollData = { title: "", options: [], votes: {} };
const KEY = 'shared_poll_state';

async function start() {
    try {
        await OviceBridge.init();
        document.getElementById('sync-info').innerText = "Sync: Connected";

        // CSV読み込み
        await loadCsv();

        // 共有データの取得
        const saved = await OviceBridge.get(KEY);
        if (saved) {
            pollData.votes = typeof saved === 'string' ? JSON.parse(saved) : saved;
            render();
        }

        // 同期リスナー
        OviceBridge.onChange((key, val) => {
            if (key === KEY) {
                pollData.votes = typeof val === 'string' ? JSON.parse(val) : val;
                render();
                document.getElementById('sync-info').innerText = "Sync: Updated " + new Date().toLocaleTimeString();
            }
        });

    } catch (e) {
        document.getElementById('sync-info').innerText = "Sync Error: " + e.message;
    }
}

async function loadCsv() {
    const res = await fetch('vote.csv?v=' + Date.now());
    const text = await res.text();
    const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l !== "");
    if (lines.length > 0) {
        pollData.title = lines[0];
        pollData.options = lines.slice(1);
        pollData.options.forEach(o => { if(!pollData.votes[o]) pollData.votes[o] = 0; });
        render();
    }
}

async function vote(option) {
    pollData.votes[option] = (pollData.votes[option] || 0) + 1;
    render();
    OviceBridge.set(KEY, pollData.votes);
}

function render() {
    document.getElementById('poll-title').innerText = pollData.title || "Poll";
    const container = document.getElementById('options');
    container.innerHTML = '';
    const total = Object.values(pollData.votes).reduce((a, b) => a + b, 0);

    pollData.options.forEach(opt => {
        const count = pollData.votes[opt] || 0;
        const per = total === 0 ? 0 : (count / total) * 100;
        const btn = document.createElement('div');
        btn.className = 'option-btn';
        btn.innerHTML = `<div class="bar" style="width:${per}%"></div><span class="label-text">${opt}</span><span class="count">${count}</span>`;
        btn.onclick = () => vote(opt);
        container.appendChild(btn);
    });
}

start();
</script>
</body>
</html>